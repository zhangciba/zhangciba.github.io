<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>HPC论文阅读笔记 | 糍粑的博客</title>
  <meta name="author" content="ZHANGCHI">
  
  <meta name="description" content="欢迎大家一起来学习">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="HPC论文阅读笔记"/>
  <meta property="og:site_name" content="糍粑的博客"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="糍粑的博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">糍粑的博客</a></h1>
  <h2><a href="/">快乐学习、快乐工作、快乐生活</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-01T09:38:16.000Z"><a href="/2016/04/01/论文阅读-Live-Migration-of-Virtual-Machines/">2016-04-01</a></time>
      
      
  
    <h1 class="title">HPC论文阅读笔记</h1>
  

    </header>
    <div class="entry">
      
        <h3 id="Live-Migration-of-Virtual-Machines"><a href="#Live-Migration-of-Virtual-Machines" class="headerlink" title="Live Migration of Virtual Machines"></a>Live Migration of Virtual Machines</h3><h3 id="论文结构"><a href="#论文结构" class="headerlink" title="论文结构"></a>论文结构</h3><ul>
<li>Abstract<br>操作系统实例的迁移是数据中心和集群管理员非常重要的工具，它可以实现软硬件之间的完美分离，用于实现错误管理，负载均衡以及低级系统维护。<br>本文作者将研究重点放在数据中心和集群环境下有服务运行的操作系统迁移的设计选项，作者引入了可写工作集的概念，并提供了在Xenp虚拟机管理器上面的设计、实现以及性能评估。</li>
<li>Introduction<br>介绍了虚拟化技术带来了很多好处，在线系统迁移就是其中之一，系统迁移可以避免进程级别迁移带来的各种困难，其次系统迁移可以让整个内存状态得到转移，这意味着可以迁移一个在线的游戏服务器和流媒体服务器，第三，在线迁移能够将用户和数据中心或集群管理员的注意力分开。</li>
<li>Realated Work<br>Collective projects研究了虚拟机迁移作为一个工具，但是不提供热迁移功能。进程迁移由于存在很多剩余的依赖问题而没有很好的解决，因此采用整个操作系统实例迁移是一个更好的办法。</li>
<li><p>Design</p>
<ul>
<li><p>Migrating Memory<br>内存迁移分为三个过程：推、停止与拷贝、拉<br>将一部分内存页传输到目的机器；<br>停止机器，并将一部分内存拷贝到目的机器<br>新机器开始运行，并将没有转移的内存pull过来</p>
<p>也有单纯停止与拷贝、按需迁移，它们分别会导致整体拓机和迁移时间过长、整体迁移时间过长的问题。</p>
</li>
<li>Local Resource<br>  虚拟机中的网络资源和本地存储的迁移是两个最重要的问题。<br>  迁移过程中要保持所有的网络连接数据都在新机器上面重现，需要在已经迁移的机器上面发出一个ARP回复，告诉其他机器，该IP地址已经改变了，其他机器将会把IP数据报发送到新的机器。但是有的路由器拒绝接受APR回复，所以该方案不适用于所情况。在交换机网络，迁移机器可以保持它的MAC地址，交换机可以检测到它迁移到了另外的端口。<br>  本文没有解决本地化磁盘迁移的问题，但是提出了几种可能的解决方案。</li>
<li><p>Design Overview<br>  作者为了达到使虚拟机迁移之后的失败几率减小，将两台虚拟机之间的迁移当作事务。</p>
<ul>
<li>预先迁移：</li>
<li>保护</li>
<li>迭代预先拷贝</li>
<li>停止与拷贝</li>
<li>提交</li>
<li>激活</li>
</ul>
</li>
<li><p>Stage0:Pre-Migration</p>
<ul>
<li>Stage1:Reservation</li>
<li>Stage2:Iterative Pre-Copy</li>
<li>Stage3:Stop-and-Copy</li>
<li>Stage4:Commitment</li>
<li>Stage5:Activation</li>
</ul>
</li>
</ul>
</li>
<li>Writable Working Sets<br>  预拷贝最重要的问题是如何决定什么时候停止预拷贝。<br>  对于内存页面，作者分为两类，一类是基本上不会变化或者变化很少的，另一类是经常会改变的，作者将这个称之为可写工作集。<ul>
<li>Measuring Writable Working Sets<br>  通过测试发现，可写工作集在不同的子基准测试程序之间变化很大。</li>
<li>Estimating Migration Effectiveness<br>  通过测试显示，提高网络带宽对于减少虚拟机拓机时间非常有帮助。</li>
</ul>
</li>
<li>Implementation Issues<ul>
<li>Managed Migration<br>  这种迁移是通过运行在源和目的主机中运行的管理虚拟机中的迁移守护程序来实现的。</li>
<li>Self Migration<br>  自我迁移是指迁移的主要功能都是在被迁移的机器本身。实现的难点在于传输一个一直的系统监测点。而且系统必须运行来保证传输它的最终状态。作者通过停止与拷贝两个阶段来解决这个难题。</li>
<li>Dynamic Rate-Limiting<br>  通过预拷贝过程中脏页的数量来决定下一轮预拷贝的带宽，得到了最佳的带宽是50Mbit/sec，在最后的停止与拷贝阶段，可以通过最大化内存传输速度最小化服务停止时间。</li>
<li>Rapid Page Dirtying<br>  操作系统中有一部分内存页的更新频率非常高，它们不仅具有时间的局部性，而且这些脏页一般具有物理聚集性（空间局部性），如果未检测到群中一页没有修改，则认为该群中的所有页都没有修改，为了避免这种弊端，可以采用假随机的顺序来检测虚拟机的物理页。</li>
<li>Paravirtualized Optimizations<br>  半虚拟化技术可以让操作系统感知到实际和虚拟环境的差别，就迁移而言它可以通过通知系统本身需要进行迁移而进行一些优化，例如发现一些异常进程、释放缓存页等。</li>
</ul>
</li>
<li><p>Evaluation</p>
<ul>
<li><p>Test Setup<br>  两台一样的Dell PE-2650服务器 2个双核至强2GHzCPU 2GB内存 BroadcomTG3网卡<br>  通过万兆以太网连接</p>
</li>
<li><p>Simple Web Server<br>  通过一台运行Apache1.3提供静态内容的虚拟机进行迁移测试，实验结果表明，高负载的服务器可以在对现有服务影响少以及较短拓机时间条件下进行迁移。</p>
</li>
<li>Complex Web Workload:SPECweb99<br>  SPECweb99具有更加复杂的页面请求，实验结果表明，一个具有重负荷的服务器只需要71s的时间进行迁移，而且没有对系统的服务质量造成影响。这进一步证明了迁移作为按需在线服务管理员的一个工具。</li>
<li>Low-Latency Server:Quake3<br>  多人在线游戏服务器也是一个具有代表性的服务环境，作者对一个运行了Quake3的服务器进行了在线迁移，实验结果除了迁移的数据量比较少之外，其他的与SPECweb99结果一致，作者也从用户的角度考虑了迁移对于用户的影响，结果表明，迁移会导致50毫秒的延时，</li>
<li>A Diabolical Workload:MMuncher<br>  这是一个极端的工作负载情况，一个512MB内存的虚拟机上面运行了一个C程序，这个C程序的功能是持续向256MB的区域写入内容。在第二个阶段，由于脏页产生的速度比网络的适配速度要高，作者的算法直接停止了第二阶段，进入第三阶段，导致了3.5秒的停机时间。但是实际情况中，不会有这样极端的负载情况。</li>
</ul>
</li>
<li>Future Work<ul>
<li>Cluster Management<br>  集群管理软件的一个挑战就是放置和移动虚拟机，作者目前正在着手开发一个基于Xen系统的集群控制器。</li>
<li>Wide Area Network Redirection<br>  本文实验是在万兆网络中进行了，如果跨局域网，则会导致延迟很大。有人提出可以在TCP层解决链接迁移的问题。</li>
<li>Migrating Block Devices<br>  NAS在现代数据中心占据了主要的位置，有些集群还会有本地存储。虚拟机集群本地存储的有效管理是作者希望将来进行深入研究的东西。</li>
</ul>
</li>
<li>Conclusion<br>  通过在Xen虚拟机管理器中加入了热系统迁移，作者实现了集群和数据中心交互工作负载的迁移。作者的动态网络带宽适应保证了迁移工作对于正在运行的服务的影响最小以及将拓机时间减少至最低。</li>
</ul>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/论文阅读，HPC，笔记，高性能计算/">论文阅读，HPC，笔记，高性能计算</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">留言</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="http://blog.zhangciba.com/2016/04/01/论文阅读-Live-Migration-of-Virtual-Machines/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:blog.zhangciba.com">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/tags/CentOS/">CentOS</a><small>1</small></li>
  
    <li><a href="/tags/Docker/">Docker</a><small>2</small></li>
  
    <li><a href="/tags/Mono/">Mono</a><small>1</small></li>
  
    <li><a href="/tags/SSH、密钥、公钥/">SSH、密钥、公钥</a><small>1</small></li>
  
    <li><a href="/tags/SSH配置/">SSH配置</a><small>1</small></li>
  
    <li><a href="/tags/数据恢复/">数据恢复</a><small>1</small></li>
  
    <li><a href="/tags/生活、感悟/">生活、感悟</a><small>1</small></li>
  
    <li><a href="/tags/论文阅读，HPC，笔记，高性能计算/">论文阅读，HPC，笔记，高性能计算</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 ZHANGCHI
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
